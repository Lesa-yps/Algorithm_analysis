% Основная часть
\section{Аналитическая часть}

\subsection{Алгоритм линейного поиска}

\hspace{1.25cm}
Линейный поиск - это метод поиска элемента в коллекции элементов. При линейном поиске каждый элемент коллекции просматривается последовательно один за другим, чтобы найти нужный элемент. Линейный поиск также известен как последовательный поиск.

Алгоритм линейного поиска можно разбить на следующие этапы:
\begin{itemize}
\item Начать: Начните с первого элемента коллекции элементов.
\item Сравнить: Сравните текущий элемент с желаемым элементом.
\item Найдено: Если текущий элемент равен искомому элементу, верните значение true или индексируйте текущий элемент.
\item Переместить: В противном случае перейдите к следующему элементу в коллекции.
\item Повтор: Повторяйте шаги 2-4, пока мы не дойдем до конца подборки.
\item Не найдено: если в конце коллекции не найден нужный элемент, верните, что нужного элемента нет в массиве.
\end{itemize}

В алгоритме линейного поиска:
\begin{itemize}
\item Каждый элемент рассматривается как потенциальное соответствие ключу и проверяется на то же самое.
\item Если найден какой-либо элемент, равный ключу, поиск завершен успешно и возвращается индекс этого элемента.
\item Если не найдено элемента, равного ключу, поиск выдает “Совпадение не найдено”.
\end{itemize}

При линейном поиске мы перебираем все элементы массива и проверяем, равен ли текущий элемент целевому элементу. Если мы обнаружим, что какой-либо элемент равен целевому элементу, то вернем индекс текущего элемента. В противном случае, если ни один элемент не равен целевому элементу, то вернем -1, поскольку элемент не найден.

Временная сложность:
\begin{itemize}
\item Лучший вариант: В лучшем случае ключ может присутствовать в первом индексе. Таким образом, сложность наилучшего варианта равна O(1)
\item Наихудший случай: В наихудшем случае ключ может присутствовать в последнем индексе, т. е. напротив конца, с которого начался поиск в списке. В то же время такую же сложность даёт и отсутствие искомого элемента в массиве. Итак, сложность наихудшего случая равна O(N), где N - размер списка.
\item Средний случай: O (N / 2)
\end{itemize}

Вспомогательное пространство: O(1) поскольку, кроме переменной для перебора по списку, никакая другая переменная не используется.

Приложения алгоритма линейного поиска:
\begin{itemize}
\item Несортированные списки: Когда у нас есть несортированный массив или список, линейный поиск чаще всего используется для поиска любого элемента в коллекции.
\item Небольшие наборы данных: Линейный поиск предпочтительнее бинарного, когда у нас есть небольшие наборы данных с
\item Поиск по связанным спискам: В реализациях связанных списков линейный поиск обычно используется для поиска элементов в списке. Каждый узел проверяется последовательно, пока не будет найден нужный элемент.
\item Простая реализация: Линейный поиск намного проще понять и реализовать по сравнению с бинарным или троичным поиском.
\end{itemize}

Преимущества алгоритма:
\begin{itemize}
\item Линейный поиск может использоваться независимо от того, отсортирован массив или нет. Его можно использовать для массивов любого типа данных.
\item Не требует дополнительной памяти.
Это хорошо подходящий алгоритм для небольших наборов данных.
\end{itemize}

Недостатки алгоритма:
\begin{itemize}
\item Линейный поиск имеет временную сложность O (N), что, в свою очередь, замедляет его выполнение для больших наборов данных.
\item Не подходит для больших массивов.
\end{itemize}

Когда использовать алгоритм?
\begin{itemize}
\item Когда мы имеем дело с небольшим набором данных.
\item При поиске набора данных, хранящегося в непрерывной памяти. \cite{geeks_linear}
\end{itemize}

\subsection{Алгоритм бинарного поиска}

\hspace{1.25cm}
Двоичный (бинарный) поиск — это алгоритм поиска, используемый для нахождения позиции целевого значения в отсортированном массиве. Он работает путем многократного деления интервала поиска пополам до тех пор, пока не будет найдено целевое значение или интервал не станет пустым. Интервал поиска делится пополам путем сравнения целевого элемента со средним значением пространства поиска.

\vspace{0.25cm}
Условия применения алгоритма бинарного поиска в структуре данных:
\begin{itemize}
\item Структура данных должна быть отсортирована.
\item Доступ к любому элементу структуры данных должен занимать постоянное время.
\end{itemize}

Ниже представлен пошаговый алгоритм бинарного поиска:

\begin{itemize}
\item Разделите пространство поиска на две половины, найдя средний индекс «mid» . 
\item Сравните средний элемент пространства поиска с ключом .
\begin{itemize}
\item Если ключ найден в среднем элементе, процесс завершается.
\item Если ключ не найден в среднем элементе, выберите, какая половина будет использоваться в качестве следующего пространства поиска.
\item Если ключ меньше среднего элемента, то для следующего поиска используется левая часть.
\item Если ключ больше среднего элемента, то для следующего поиска используется правая часть.
\end{itemize}
\item Этот процесс продолжается до тех пор, пока не будет найден ключ или не будет исчерпан весь объем пространства поиска.
\end{itemize}

Алгоритм двоичного поиска может быть реализован следующими двумя способами:
\begin{itemize}
\item Алгоритм итерационного бинарного поиска
\item Алгоритм рекурсивного бинарного поиска
\end{itemize}

Анализ сложности алгоритма бинарного поиска:
\begin{itemize}
\item Лучший случай: O(1)
\item Средний случай: O(log N)
\item Худший случай: O(log N)
\end{itemize}

Вспомогательное пространство: O(1). Если рассматривать стек рекурсивных вызовов, то вспомогательное пространство будет O(logN).

Применение алгоритма бинарного поиска:
\begin{itemize}
\item Двоичный поиск можно использовать в качестве строительного блока для более сложных алгоритмов, используемых в машинном обучении, таких как алгоритмы обучения нейронных сетей или поиска оптимальных гиперпараметров для модели.
\item Его можно использовать для поиска в компьютерной графике, например, в алгоритмах трассировки лучей или наложения текстур.
\item Его можно использовать для поиска в базе данных.
\end{itemize}

Преимущества бинарного поиска:
\begin{itemize}
\item Двоичный поиск быстрее линейного поиска, особенно для больших массивов.
\item Более эффективен, чем другие алгоритмы поиска с аналогичной временной сложностью, такие как интерполяционный поиск или экспоненциальный поиск.
\item Двоичный поиск хорошо подходит для поиска в больших наборах данных, хранящихся во внешней памяти, например на жестком диске или в облаке.
\end{itemize}

Недостатки бинарного поиска:
\begin{itemize}
\item Массив должен быть отсортирован.
\item Двоичный поиск требует, чтобы искомая структура данных хранилась в смежных ячейках памяти.
\item Двоичный поиск требует, чтобы элементы массива были сопоставимы, то есть их нужно упорядочить. \cite{geeks_binary}
\end{itemize}

Оценка трудоёмкости для "холодного" старта алгоритма:
\[f_{\text{бин. поиск}} = f_{\text{сорт}} + f_{\text{поиск}}\]

Оценка трудоёмкости алгоритма на отсортированном массиве из N элементов:
\begin{equation}
    f_{\text{бин. поиск}} = f_{\text{сорт}} + 
    \begin{cases}
      O(1) & \text{лучший случай (элемент на 1-ом месте)}; \\
      O(N) & \text{худший случай (элемент на N-ом месте или отсутствует)}.
    \end{cases}
\end{equation}

\subsection{Сортировка}

\subsubsection*{Виды сортировок}

\hspace{1.25cm}
Так как бинарный поиск работает только с отсортированными массивами, необходимо подробнее рассмотреть сортировки.

Сортировка — это процесс упорядочивания элементов в списке по определенному критерию. Существует множество алгоритмов сортировки, и они могут быть классифицированы по различным критериям, таким как производительность, дополнительные по памяти и устойчивость.

Рассмотрим некоторые распространенные виды сортировок:

\begin{itemize}

\item Сортировка пузырьком (Bubble Sort):

Простой алгоритм, который многократно проходит по списку, сравнивая соседние элементы и меняя их местами, если они находятся в неверном порядке.

Время выполнения:
\begin{itemize}
\item O(n²) в худшем и среднем случаях;
\item O(n) в лучшем случае (если список уже отсортирован).
\end{itemize}

\item Сортировка вставками (Insertion Sort):

Элементы сортируются по одному, вставляя их в правильное положение в уже отсортированной части списка.

Время выполнения:
\begin{itemize}
\item O(n²) в худшем и среднем случаях;
\item O(n) в лучшем случае (при помощи уже отсортированного списка).
\end{itemize}

\item Сортировка выбором (Selection Sort):

На каждом проходе выбирается наименьший (или наибольший) элемент и помещается в начало (или конец) списка.

Время выполнения: O(n²) для всех случаев.

\item Сортировка слиянием (Merge Sort):

Алгоритм типа "разделяй и властвуй", который разбивает список на две части, сортирует их и затем объединяет.

Время выполнения: \(O(n * \log n)\) во всех случаях.

\item Быстрая сортировка (Quick Sort):

Также алгоритм "разделяй и властвуй", который выбирает опорный элемент, распределяет элементы по сравнению с опорным и рекурсивно сортирует подсписки.

Время выполнения:
\begin{itemize}
\item \(O(n * \log n)\) в среднем случае;
\item O(n²) в худшем случае (например, если массив уже отсортирован).
\end{itemize}

\item Пирамидальная сортировка (Heap Sort):

Основан на структуре данных "куча". Алгоритм строит кучу из массива и затем извлекает максимальные элементы, перестраивая кучу.

Время выполнения: \(O(n * \log n)\) во всех случаях.

\end{itemize}

\subsubsection*{Сортировка выбором}

\hspace{1.25cm}
В связи с простотой реализации, стабильной сложностью и отсутствием необходимости дополнительной памяти для подготовки массива к бинарному поиску решено было реализовать сортировку выбором.

Алгоритм сортировки выбором:

\begin{enumerate}

\item Вычислить длину переданного массива;

\item Пройтись по всем элементам массива;

\begin{enumerate}

\item Запомнить индекс текущего элемента как индекс минимального для текущего шага;

\item Пройтись по оставшимся элементам массива;

Сравнить запомненный минимальный с текущим элементом и запомнить текущий, если он меньше запомненного.

\item Обменять элемент с запомненным как минимальный индексом с текущим;

\end{enumerate}

\end{enumerate}

Таким образом трудоёмкость сортировки выбором для массива длиной n будет следующей:

\begin{equation}
f_{\text{сорт}} = 1 + 2 + n \cdot \left(2 + 1 + 5 + 2 + (n - i - 1) \cdot \left(2 + 3 + \left\{\begin{array}{ll}
0, & \text{лучший случай} \\
1, & \text{худший случай}
\end{array}\right.\right)\right)
\end{equation}

\newpage